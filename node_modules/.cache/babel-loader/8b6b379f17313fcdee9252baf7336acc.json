{"ast":null,"code":"export default function CSVToArray(strData, strDelimiter) {\n  // Check to see if the delimiter is defined. If not,\n  // then default to comma.\n  strDelimiter = strDelimiter || \",\"; // Create a regular expression to parse the CSV values.\n\n  var objPattern = new RegExp( // Delimiters.\n  \"(\\\\\" + strDelimiter + \"|\\\\r?\\\\n|\\\\r|^)\" + // Quoted fields.\n  \"(?:\\\"([^\\\"]*(?:\\\"\\\"[^\\\"]*)*)\\\"|\" + // Standard fields.\n  \"([^\\\"\\\\\" + strDelimiter + \"\\\\r\\\\n]*))\", \"gi\"); // Create an array to hold our data. Give the array\n  // a default empty first row.\n\n  var arrData = [[]]; // Create an array to hold our individual pattern\n  // matching groups.\n\n  var arrMatches = null; // Keep looping over the regular expression matches\n  // until we can no longer find a match.\n\n  while (arrMatches = objPattern.exec(strData)) {\n    // Get the delimiter that was found.\n    var strMatchedDelimiter = arrMatches[1]; // Check to see if the given delimiter has a length\n    // (is not the start of string) and if it matches\n    // field delimiter. If id does not, then we know\n    // that this delimiter is a row delimiter.\n\n    if (strMatchedDelimiter.length && strMatchedDelimiter !== strDelimiter) {\n      // Since we have reached a new row of data,\n      // add an empty row to our data array.\n      arrData.push([]);\n    }\n\n    var strMatchedValue; // Now that we have our delimiter out of the way,\n    // let's check to see which kind of value we\n    // captured (quoted or unquoted).\n\n    if (arrMatches[2]) {\n      // We found a quoted value. When we capture\n      // this value, unescape any double quotes.\n      strMatchedValue = arrMatches[2].replace(new RegExp(\"\\\"\\\"\", \"g\"), \"\\\"\");\n    } else {\n      // We found a non-quoted value.\n      strMatchedValue = arrMatches[3];\n    } // Now that we have our value string, let's add\n    // it to the data array.\n\n\n    arrData[arrData.length - 1].push(strMatchedValue);\n  } // Return the parsed data.\n\n\n  return arrData;\n}\n_c = CSVToArray;\n\nvar _c;\n\n$RefreshReg$(_c, \"CSVToArray\");","map":{"version":3,"sources":["/Users/fulica/Projects/AAD_react/src/utils/CSVToArray.js"],"names":["CSVToArray","strData","strDelimiter","objPattern","RegExp","arrData","arrMatches","exec","strMatchedDelimiter","length","push","strMatchedValue","replace"],"mappings":"AAAA,eAAe,SAASA,UAAT,CAAoBC,OAApB,EAA6BC,YAA7B,EAA2C;AACtD;AACA;AACAA,EAAAA,YAAY,GAAIA,YAAY,IAAI,GAAhC,CAHsD,CAKtD;;AACA,MAAIC,UAAU,GAAG,IAAIC,MAAJ,EAET;AACA,UAAQF,YAAR,GAAuB,iBAAvB,GAEA;AACA,mCAHA,GAKA;AACA,WANA,GAMYA,YANZ,GAM2B,YATlB,EAWb,IAXa,CAAjB,CANsD,CAqBtD;AACA;;AACA,MAAIG,OAAO,GAAG,CAAC,EAAD,CAAd,CAvBsD,CAyBtD;AACA;;AACA,MAAIC,UAAU,GAAG,IAAjB,CA3BsD,CA8BtD;AACA;;AACA,SAAOA,UAAU,GAAGH,UAAU,CAACI,IAAX,CAAgBN,OAAhB,CAApB,EAA8C;AAE1C;AACA,QAAIO,mBAAmB,GAAGF,UAAU,CAAC,CAAD,CAApC,CAH0C,CAK1C;AACA;AACA;AACA;;AACA,QAAIE,mBAAmB,CAACC,MAApB,IACAD,mBAAmB,KAAKN,YAD5B,EAC0C;AAEtC;AACA;AACAG,MAAAA,OAAO,CAACK,IAAR,CAAa,EAAb;AAEH;;AAED,QAAIC,eAAJ,CAlB0C,CAoB1C;AACA;AACA;;AACA,QAAIL,UAAU,CAAC,CAAD,CAAd,EAAmB;AAEf;AACA;AACAK,MAAAA,eAAe,GAAGL,UAAU,CAAC,CAAD,CAAV,CAAcM,OAAd,CACd,IAAIR,MAAJ,CAAW,MAAX,EAAmB,GAAnB,CADc,EAEd,IAFc,CAAlB;AAKH,KATD,MASO;AAEH;AACAO,MAAAA,eAAe,GAAGL,UAAU,CAAC,CAAD,CAA5B;AAEH,KArCyC,CAwC1C;AACA;;;AACAD,IAAAA,OAAO,CAACA,OAAO,CAACI,MAAR,GAAiB,CAAlB,CAAP,CAA4BC,IAA5B,CAAiCC,eAAjC;AACH,GA3EqD,CA6EtD;;;AACA,SAAQN,OAAR;AACH;KA/EuBL,U","sourcesContent":["export default function CSVToArray(strData, strDelimiter) {\n    // Check to see if the delimiter is defined. If not,\n    // then default to comma.\n    strDelimiter = (strDelimiter || \",\");\n\n    // Create a regular expression to parse the CSV values.\n    var objPattern = new RegExp(\n        (\n            // Delimiters.\n            \"(\\\\\" + strDelimiter + \"|\\\\r?\\\\n|\\\\r|^)\" +\n\n            // Quoted fields.\n            \"(?:\\\"([^\\\"]*(?:\\\"\\\"[^\\\"]*)*)\\\"|\" +\n\n            // Standard fields.\n            \"([^\\\"\\\\\" + strDelimiter + \"\\\\r\\\\n]*))\"\n        ),\n        \"gi\"\n    );\n\n\n    // Create an array to hold our data. Give the array\n    // a default empty first row.\n    var arrData = [[]];\n\n    // Create an array to hold our individual pattern\n    // matching groups.\n    var arrMatches = null;\n\n\n    // Keep looping over the regular expression matches\n    // until we can no longer find a match.\n    while (arrMatches = objPattern.exec(strData)) {\n\n        // Get the delimiter that was found.\n        var strMatchedDelimiter = arrMatches[1];\n\n        // Check to see if the given delimiter has a length\n        // (is not the start of string) and if it matches\n        // field delimiter. If id does not, then we know\n        // that this delimiter is a row delimiter.\n        if (strMatchedDelimiter.length &&\n            strMatchedDelimiter !== strDelimiter) {\n\n            // Since we have reached a new row of data,\n            // add an empty row to our data array.\n            arrData.push([]);\n\n        }\n\n        var strMatchedValue;\n\n        // Now that we have our delimiter out of the way,\n        // let's check to see which kind of value we\n        // captured (quoted or unquoted).\n        if (arrMatches[2]) {\n\n            // We found a quoted value. When we capture\n            // this value, unescape any double quotes.\n            strMatchedValue = arrMatches[2].replace(\n                new RegExp(\"\\\"\\\"\", \"g\"),\n                \"\\\"\"\n            );\n\n        } else {\n\n            // We found a non-quoted value.\n            strMatchedValue = arrMatches[3];\n\n        }\n\n\n        // Now that we have our value string, let's add\n        // it to the data array.\n        arrData[arrData.length - 1].push(strMatchedValue);\n    }\n\n    // Return the parsed data.\n    return (arrData);\n}"]},"metadata":{},"sourceType":"module"}